import { useNuxt, createResolver, addTemplate, loadNuxtModuleInstance, defineNuxtModule, useLogger, hasNuxtModule, getNuxtModuleVersion, hasNuxtModuleCompatibility, extendPages, findPath, addServerHandler, addPrerenderRoutes, addServerPlugin } from '@nuxt/kit';
import { joinURL, hasProtocol, withoutBase, withoutTrailingSlash, withoutLeadingSlash, withBase } from 'ufo';
import { assertSiteConfig, withSiteUrl, createSitePathResolver, installNuxtSiteConfig, updateSiteConfig } from 'nuxt-site-config-kit';
import { addCustomTab } from '@nuxt/devtools-kit';
import { relative, extname } from 'pathe';
import { statSync } from 'node:fs';
import { mkdir, writeFile } from 'node:fs/promises';
import chalk from 'chalk';
import { toRouteMatcher, createRouter } from 'radix3';
import { defu } from 'defu';
import { fixSlashes } from 'site-config-stack';
import 'knitwork';
import 'escape-string-regexp';

const version = "3.4.0";

function extendTypes(module, template) {
  const nuxt = useNuxt();
  const { resolve } = createResolver(import.meta.url);
  addTemplate({
    filename: `module/${module}.d.ts`,
    getContents: async () => {
      const typesPath = relative(resolve(nuxt.options.rootDir, nuxt.options.buildDir, "module"), resolve("runtime/types"));
      const s = await template({ typesPath });
      return `// Generated by ${module}
${s}
export {}
`;
    }
  });
  nuxt.hooks.hook("prepare:types", ({ references }) => {
    references.push({ path: resolve(nuxt.options.buildDir, `module/${module}.d.ts`) });
  });
}

function convertNuxtPagesToSitemapEntries(pages, config) {
  const routeNameSeperator = config.routeNameSeperator || "___";
  const flattenedPages = pages.map((page) => {
    return page.children?.length ? page.children.map((child) => {
      return {
        loc: joinURL(page.path, child.path),
        page: child
      };
    }) : { page, loc: page.path };
  }).flat().filter((p) => !p.loc.includes(":"));
  const pagesWithMeta = flattenedPages.map((p) => {
    if (config.autoLastmod && p.page.file) {
      try {
        const stats = statSync(p.page.file);
        if (stats)
          p.lastmod = stats.mtime;
      } catch (e) {
      }
    }
    return p;
  });
  const localeGroups = {};
  pagesWithMeta.reduce((acc, entry) => {
    if (entry.page.name?.includes(routeNameSeperator)) {
      const [name, locale] = entry.page.name.split(routeNameSeperator);
      if (!acc[name])
        acc[name] = [];
      acc[name].push({ ...entry, locale });
    } else {
      acc.default = acc.default || [];
      acc.default.push(entry);
    }
    return acc;
  }, localeGroups);
  const final = Object.entries(localeGroups).map(([locale, entries]) => {
    if (locale === "default") {
      if (config.strategy === "prefix")
        return [];
      return entries.map((e) => {
        delete e.page;
        delete e.locale;
        return e;
      });
    }
    return entries.map((entry) => {
      const alternatives = entries.map((entry2) => {
        const hreflang = config.normalisedLocales.find((l) => l.code === entry2.locale)?.iso || entry2.locale;
        return {
          hreflang,
          href: entry2.loc
        };
      });
      const xDefault = entries.find((a) => a.locale === config.defaultLocale);
      if (xDefault) {
        alternatives.push({
          hreflang: "x-default",
          href: xDefault.loc
        });
      }
      const e = { ...entry };
      delete e.page;
      delete e.locale;
      return {
        ...e,
        alternatives
      };
    });
  }).filter(Boolean).flat();
  return final;
}
async function getNuxtModuleOptions(module, nuxt = useNuxt()) {
  const moduleMeta = (typeof module === "string" ? { name: module } : await module.getMeta?.()) || {};
  const { nuxtModule } = await loadNuxtModuleInstance(module, nuxt);
  const inlineOptions = (await Promise.all(
    nuxt.options.modules.filter(async (m) => {
      if (!Array.isArray(m))
        return false;
      const _module = m[0];
      return typeof module === "object" ? await _module.getMeta?.() === moduleMeta.name : _module === moduleMeta.name;
    }).map((m) => m?.[1])
  ))[0] || {};
  if (nuxtModule.getOptions)
    return nuxtModule.getOptions(inlineOptions, nuxt);
  return inlineOptions;
}
function generateExtraRoutesFromNuxtConfig(nuxt = useNuxt()) {
  const routeRules = Object.entries(nuxt.options.routeRules || {}).filter(([k, v]) => {
    if (k.includes("*") || k.includes(".") || k.includes(":"))
      return false;
    if (typeof v.index === "boolean" && !v.index)
      return false;
    return !v.redirect;
  }).map(([k]) => k);
  const prerenderUrls = (nuxt.options.nitro.prerender?.routes || []).filter((p) => p && !extname(p) && !p.startsWith("/api/"));
  return { routeRules, prerenderUrls };
}

async function resolveUrls(urls) {
  if (typeof urls === "function")
    urls = urls();
  urls = await urls;
  return urls;
}
async function resolveAsyncDataSources(input) {
  const { hasPrerenderedRoutesPayload, isNuxtContentDocumentDriven } = input.buildTimeMeta;
  const entries = [];
  entries.push({
    context: "pages",
    urls: input.pages
  });
  if (input.prerenderUrls) {
    entries.push({
      context: "prerender",
      urls: input.prerenderUrls
    });
  }
  if (input.extraRoutes.prerenderUrls.length) {
    entries.push({
      context: "nuxt-config.nitro-prerender",
      urls: input.extraRoutes.prerenderUrls
    });
  }
  if (input.extraRoutes.routeRules.length) {
    entries.push({
      context: "nuxt-config.route-rules",
      urls: input.extraRoutes.routeRules
    });
  }
  entries.push({
    context: "nuxt-config.module",
    path: "urls",
    urls: await resolveUrls(input.moduleConfig.urls)
  });
  function doFetch(url, timeout = 8e3) {
    const context = "api";
    const start = Date.now();
    const timeoutController = new AbortController();
    const abortRequestTimeout = setTimeout(() => timeoutController.abort(), timeout);
    let isHtmlResponse = false;
    return globalThis.$fetch(url, {
      responseType: "json",
      signal: timeoutController.signal,
      headers: {
        Accept: "application/json"
      },
      onResponse({ response }) {
        if (typeof response._data === "string" && response._data.startsWith("<!DOCTYPE html>"))
          isHtmlResponse = true;
      }
    }).then((urls) => {
      const timeTakenMs = Date.now() - start;
      if (isHtmlResponse) {
        entries.push({
          context,
          timeTakenMs,
          urls: [],
          path: url,
          error: "Received HTML response instead of JSON"
        });
      } else {
        entries.push({
          context,
          timeTakenMs,
          path: url,
          urls
        });
      }
    }).catch((err) => {
      entries.push({
        context,
        urls: [],
        path: url,
        error: err
      });
    }).finally(() => {
      abortRequestTimeout && clearTimeout(abortRequestTimeout);
    });
  }
  const waitables = [];
  async function loadSitemapSources(sitemap) {
    if (sitemap.urls) {
      entries.push({
        context: "nuxt-config.module",
        path: `sitemaps.${sitemap.sitemapName}.urls`,
        urls: await resolveUrls(sitemap.urls)
      });
    }
    if (sitemap.dynamicUrlsApiEndpoint)
      waitables.push(doFetch(sitemap.dynamicUrlsApiEndpoint));
  }
  if (input.buildTimeMeta.hasApiRoutesUrl)
    waitables.push(doFetch(input.moduleConfig.dynamicUrlsApiEndpoint));
  if (!input.sitemap && typeof input.moduleConfig.sitemaps === "object") {
    for (const entry of Object.entries(input.moduleConfig.sitemaps)) {
      const [sitemapName, sitemap] = entry;
      await loadSitemapSources({
        sitemapName,
        ...sitemap
      });
    }
  } else if (input.sitemap) {
    await loadSitemapSources(input.sitemap);
  }
  if (hasPrerenderedRoutesPayload)
    waitables.push(doFetch(input.canonicalUrlResolver("/__sitemap__/routes.json"), 1500));
  if (isNuxtContentDocumentDriven)
    waitables.push(doFetch("/api/__sitemap__/document-driven-urls", 4e3));
  await Promise.all(waitables);
  return entries;
}

function createFilter(options = {}) {
  const include = options.include || [];
  const exclude = options.exclude || [];
  if (include.length === 0 && exclude.length === 0)
    return () => true;
  return function(path) {
    for (const v of [{ rules: exclude, result: false }, { rules: include, result: true }]) {
      const regexRules = v.rules.filter((r) => r instanceof RegExp);
      if (regexRules.some((r) => r.test(path)))
        return v.result;
      const stringRules = v.rules.filter((r) => typeof r === "string");
      if (stringRules.length > 0) {
        const routes = {};
        for (const r of stringRules) {
          if (r === path)
            return v.result;
          routes[r] = true;
        }
        const routeRulesMatcher = toRouteMatcher(createRouter({ routes, strictTrailingSlash: false }));
        if (routeRulesMatcher.matchAll(path).length > 0)
          return Boolean(v.result);
      }
    }
    return include.length === 0;
  };
}

function mergeOnKey(arr, key) {
  const res = {};
  arr.forEach((item) => {
    const k = item[key];
    res[k] = defu(item, res[k] || {});
  });
  return Object.values(res);
}

async function normaliseSitemapData(data, options) {
  const {
    defaults,
    exclude,
    include,
    autoLastmod,
    autoI18n,
    isI18nMap
  } = options.moduleConfig;
  const combinedInclude = [...options.sitemap?.include || [], ...include || []];
  const combinedExclude = [...options.sitemap?.exclude || [], ...exclude || []];
  const urlFilter = createFilter({ include: combinedInclude, exclude: combinedExclude });
  function resolve(s) {
    if (!s)
      return;
    s = typeof s === "string" ? s : s.toString();
    if (hasProtocol(s, { acceptRelative: true, strict: false })) {
      if (s.startsWith(options.canonicalUrlResolver("/")))
        s = s.replace(options.canonicalUrlResolver("/"), "");
      else
        return s;
    }
    return options.canonicalUrlResolver(s);
  }
  const defaultEntryData = defu(options.sitemap?.defaults, defaults);
  if (autoLastmod)
    defaultEntryData.lastmod = defaultEntryData.lastmod || /* @__PURE__ */ new Date();
  let entries = data.map((e) => typeof e === "string" ? { loc: e } : e).map((e) => {
    e = { ...e };
    if (e.url) {
      e.loc = e.url;
      delete e.url;
    }
    e.loc = fixSlashes(false, e.loc);
    e = defu(e, defaultEntryData);
    return e;
  }).map((e) => {
    const routeRules = options.getRouteRulesForPath(e.loc);
    if (routeRules.index === false)
      return false;
    return defu(routeRules.sitemap || {}, e);
  }).filter(Boolean);
  if (autoI18n?.locales) {
    const entriesByLoc = entries.reduce((acc, e) => {
      const match = e.loc.match(new RegExp(`^/(${autoI18n.locales.map((l) => l.code).join("|")})(.*)`));
      let loc = e.loc;
      let prefix = null;
      if (match) {
        loc = match[2] || "/";
        prefix = match[1];
      }
      acc[loc] = acc[loc] || [];
      acc[loc].push({ entry: e, prefix });
      return acc;
    }, {});
    Object.entries(entriesByLoc).forEach(([loc, childEntry]) => {
      autoI18n.locales.map((l) => l.code).forEach((prefix) => {
        if (!childEntry.map((e) => e.prefix).filter(Boolean).includes(prefix)) {
          if (autoI18n.strategy === "prefix")
            entries.push({ ...childEntry[0].entry, loc: joinURL(`/${prefix}`, loc) });
          else if (autoI18n.strategy === "prefix_except_default")
            entries.push({ ...childEntry[0].entry, loc: prefix === autoI18n.defaultLocale ? loc : joinURL(`/${prefix}`, loc) });
        }
      });
    });
    entries.map((e) => {
      let withoutPrefix = e.loc.replace(new RegExp(`^/(${autoI18n.locales.map((l) => l.code).join("|")})(.*)`), "$2");
      withoutPrefix = withoutPrefix || "/";
      let xDefault = e.loc;
      if (autoI18n.strategy === "prefix") {
        xDefault = joinURL("/", autoI18n.defaultLocale, withoutPrefix);
      } else if (autoI18n.strategy === "prefix_except_default") {
        xDefault = withoutPrefix;
      }
      e.alternatives = e.alternatives || [
        ...autoI18n.locales.map((locale) => {
          const isDefault = locale.code === autoI18n.defaultLocale;
          let href = "";
          if (autoI18n.strategy === "prefix") {
            href = joinURL("/", locale.code, withoutPrefix);
          } else if (autoI18n.strategy === "prefix_except_default") {
            if (isDefault) {
              href = withoutPrefix;
            } else {
              href = joinURL("/", locale.code, withoutPrefix);
            }
          }
          const hreflang = locale.iso || locale.code;
          return {
            hreflang,
            href
          };
        }),
        { hreflang: "x-default", href: xDefault }
      ];
      return e;
    });
    if (autoI18n.strategy === "prefix") {
      entries = entries.filter((e) => e.loc.match(new RegExp(`^/(${autoI18n.locales.map((l) => l.code).join("|")})(.*)`)));
    }
  }
  let filteredEntries = entries.filter((e) => e && urlFilter(e.loc));
  if (isI18nMap && options.sitemap?.sitemapName) {
    const locale = options.sitemap?.sitemapName;
    filteredEntries = filteredEntries.filter((e) => {
      const alternativeEntry = e.alternatives?.find((a) => a.hreflang === locale);
      if (!alternativeEntry)
        return false;
      return alternativeEntry.href === e.loc;
    });
  }
  function normaliseEntry(e) {
    if (e.lastmod) {
      const date = normaliseDate(e.lastmod);
      if (date)
        e.lastmod = date;
      else
        delete e.lastmod;
    }
    if (!e.lastmod)
      delete e.lastmod;
    e.loc = resolve(e.loc);
    if (e.alternatives) {
      e.alternatives = mergeOnKey(e.alternatives.map((e2) => {
        const a = { ...e2 };
        if (typeof a.href === "string")
          a.href = resolve(a.href);
        else if (typeof a.href === "object" && a.href)
          a.href = resolve(a.href.href);
        return a;
      }), "hreflang");
    }
    if (e.images) {
      e.images = mergeOnKey(e.images.map((i) => {
        i = { ...i };
        i.loc = resolve(i.loc);
        return i;
      }), "loc");
    }
    if (e.videos) {
      e.videos = e.videos.map((v) => {
        v = { ...v };
        v.contentLoc = resolve(v.contentLoc);
        return v;
      });
    }
    return e;
  }
  function sortEntries(entries2) {
    if (options.moduleConfig.sortEntries) {
      return entries2.sort((a, b) => {
        return a.loc.localeCompare(b.loc, void 0, { numeric: true });
      }).sort((a, b) => {
        const aSegments = a.loc.split("/").length;
        const bSegments = b.loc.split("/").length;
        if (aSegments > bSegments)
          return 1;
        if (aSegments < bSegments)
          return -1;
        return 0;
      });
    }
    return entries2;
  }
  function normaliseEntries(entries2) {
    return sortEntries(mergeOnKey(entries2.map(normaliseEntry), "loc"));
  }
  const ctx = { urls: normaliseEntries(filteredEntries), sitemapName: options.sitemap?.sitemapName || "sitemap" };
  if (options.callHook)
    await options.callHook(ctx);
  return normaliseEntries(ctx.urls);
}
function normaliseDate(date) {
  const d = typeof date === "string" ? new Date(date) : date;
  if (!(d instanceof Date))
    return false;
  const z = (n) => `0${n}`.slice(-2);
  return `${d.getUTCFullYear()}-${z(d.getUTCMonth() + 1)}-${z(d.getUTCDate())}T${z(d.getUTCHours())}:${z(d.getUTCMinutes())}:${z(d.getUTCSeconds())}+00:00`;
}

function wrapSitemapXml(input, { xsl, credits, version }) {
  input.unshift(`<?xml version="1.0" encoding="UTF-8"?>${xsl ? `<?xml-stylesheet type="text/xsl" href="${xsl}"?>` : ""}`);
  if (credits)
    input.push(`<!-- XML Sitemap generated by Nuxt Simple Sitemap V${version} -->`);
  return input.join("\n");
}
function escapeValueForXml(value) {
  if (value === true || value === false)
    return value ? "yes" : "no";
  return String(value).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
}

async function buildSitemap(options) {
  const sitemapsConfig = options.moduleConfig.sitemaps;
  const sources = await resolveAsyncDataSources(options);
  let entries = await normaliseSitemapData(sources.map((e) => e.urls).flat(), options);
  if (sitemapsConfig === true && options.moduleConfig.defaultSitemapsChunkSize)
    entries = entries.slice(Number(options.sitemap?.sitemapName) * options.moduleConfig.defaultSitemapsChunkSize, (Number(options.sitemap?.sitemapName) + 1) * options.moduleConfig.defaultSitemapsChunkSize);
  function resolveKey(k) {
    switch (k) {
      case "images":
        return "image";
      case "videos":
        return "video";
      case "news":
        return "news";
      default:
        return k;
    }
  }
  function handleObject(key, obj) {
    return [
      `        <${key}:${key}>`,
      ...Object.entries(obj).map(([sk, sv]) => {
        if (typeof sv === "object") {
          return [
            `            <${key}:${sk}>`,
            ...Object.entries(sv).map(([ssk, ssv]) => `                <${key}:${ssk}>${escapeValueForXml(ssv)}</${key}:${ssk}>`),
            `            </${key}:${sk}>`
          ].join("\n");
        }
        return `            <${key}:${sk}>${escapeValueForXml(sv)}</${key}:${sk}>`;
      }),
      `        </${key}:${key}>`
    ].join("\n");
  }
  function handleArray(key, arr) {
    if (arr.length === 0)
      return false;
    key = resolveKey(key);
    if (key === "alternatives") {
      return arr.map((obj) => [
        `        <xhtml:link rel="alternate" ${Object.entries(obj).map(([sk, sv]) => `${sk}="${escapeValueForXml(sv)}"`).join(" ")} />`
      ].join("\n")).join("\n");
    }
    return arr.map((obj) => handleObject(key, obj)).join("\n");
  }
  function handleEntry(k, e) {
    return Array.isArray(e[k]) ? handleArray(k, e[k]) : typeof e[k] === "object" ? handleObject(k, e[k]) : `        <${k}>${escapeValueForXml(e[k])}</${k}>`;
  }
  return wrapSitemapXml([
    '<urlset xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:video="http://www.google.com/schemas/sitemap-video/1.1" xmlns:xhtml="http://www.w3.org/1999/xhtml" xmlns:image="http://www.google.com/schemas/sitemap-image/1.1" xmlns:news="http://www.google.com/schemas/sitemap-news/0.9" xsi:schemaLocation="http://www.sitemaps.org/schemas/sitemap/0.9 http://www.sitemaps.org/schemas/sitemap/0.9/sitemap.xsd http://www.google.com/schemas/sitemap-image/1.1 http://www.google.com/schemas/sitemap-image/1.1/sitemap-image.xsd" xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">',
    ...entries?.map((e) => `    <url>
${Object.keys(e).map((k) => handleEntry(k, e)).filter((l) => l !== false).join("\n")}
    </url>`) ?? [],
    "</urlset>"
  ], {
    xsl: options.moduleConfig.xsl ? options.relativeBaseUrlResolver(options.moduleConfig.xsl) : false,
    credits: options.moduleConfig.credits,
    version: options.buildTimeMeta.version
  });
}

async function buildSitemapIndex(options) {
  const multiSitemapConfig = options.moduleConfig.sitemaps;
  if (!multiSitemapConfig)
    throw new Error("Attempting to build a sitemap index without required `sitemaps` configuration.");
  const chunks = {};
  const rawEntries = await resolveAsyncDataSources(options);
  if (multiSitemapConfig === true) {
    const urls = await normaliseSitemapData(rawEntries.map((e) => e.urls).flat(), options);
    urls.forEach((url, i) => {
      const chunkIndex = Math.floor(i / options.moduleConfig.defaultSitemapsChunkSize);
      chunks[chunkIndex] = chunks[chunkIndex] || { urls: [] };
      chunks[chunkIndex].urls.push(url);
    });
  } else {
    for (const sitemap in multiSitemapConfig) {
      if (sitemap !== "index") {
        chunks[sitemap] = chunks[sitemap] || { urls: [] };
        chunks[sitemap].urls = await normaliseSitemapData(rawEntries.map((e) => e.urls).flat(), defu({ sitemap: multiSitemapConfig[sitemap] }, options));
      }
    }
  }
  const entries = [];
  const sitemaps = [];
  for (const sitemapName in chunks) {
    const sitemap = chunks[sitemapName];
    const entry = {
      sitemap: options.canonicalUrlResolver(`${sitemapName}-sitemap.xml`)
    };
    let lastmod = sitemap.urls.filter((a) => !!a?.lastmod).map((a) => typeof a.lastmod === "string" ? new Date(a.lastmod) : a.lastmod).sort((a, b) => (b?.getTime() || 0) - (a?.getTime() || 0))?.[0];
    if (!lastmod && options.moduleConfig.autoLastmod)
      lastmod = /* @__PURE__ */ new Date();
    if (lastmod)
      entry.lastmod = normaliseDate(lastmod);
    entries.push(entry);
    sitemaps.push({
      sitemapName,
      urls: sitemap.urls
    });
  }
  if (multiSitemapConfig !== true && multiSitemapConfig.index) {
    entries.push(...multiSitemapConfig.index.map((s) => {
      return typeof s === "string" ? { sitemap: s } : s;
    }));
  }
  return {
    sitemaps,
    xml: generateSitemapIndexXml(entries, {
      xsl: options.moduleConfig.xsl ? options.relativeBaseUrlResolver(options.moduleConfig.xsl) : false,
      credits: options.moduleConfig.credits,
      version: options.buildTimeMeta.version
    })
  };
}
function generateSitemapIndexXml(entries, options) {
  const sitemapXml = entries.map((e) => [
    "    <sitemap>",
    `        <loc>${escapeValueForXml(e.sitemap)}</loc>`,
    // lastmod is optional
    e.lastmod ? `        <lastmod>${escapeValueForXml(e.lastmod)}</lastmod>` : false,
    "    </sitemap>"
  ].filter(Boolean).join("\n")).join("\n");
  return wrapSitemapXml([
    '<sitemapindex xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">',
    sitemapXml,
    "</sitemapindex>"
  ], options);
}

function setupPrerenderHandler(moduleConfig, buildTimeMeta, pagesPromise, nuxt = useNuxt()) {
  const { resolve } = createResolver(import.meta.url);
  nuxt.hooks.hook("nitro:init", async (nitro) => {
    const sitemapImages = {};
    nitro.hooks.hook("prerender:init", () => {
      assertSiteConfig("nuxt-simple-sitemap", {
        url: "Required to generate absolute canonical URLs for your sitemap."
      }, { throwError: false });
    });
    nitro.hooks.hook("prerender:route", async (ctx) => {
      const html = ctx.contents;
      if (ctx.fileName?.endsWith(".html") && html) {
        const mainRegex = /<main[^>]*>([\s\S]*?)<\/main>/;
        const mainMatch = mainRegex.exec(html);
        if (!mainMatch || !mainMatch[1])
          return;
        if (moduleConfig.discoverImages && mainMatch[1].includes("<img")) {
          const imgRegex = /<img[^>]+src="([^">]+)"/g;
          let match;
          while ((match = imgRegex.exec(mainMatch[1])) !== null) {
            if (match.index === imgRegex.lastIndex)
              imgRegex.lastIndex++;
            let url = match[1];
            if (url.startsWith("/"))
              url = withSiteUrl(url);
            sitemapImages[ctx.route] = sitemapImages[ctx.route] || [];
            sitemapImages[ctx.route].push({
              loc: url
            });
          }
        }
      }
    });
    let sitemapGenerated = false;
    const outputSitemap = async () => {
      if (sitemapGenerated || nuxt.options.dev || nuxt.options._prepare)
        return;
      const prerenderUrls = (nitro._prerenderedRoutes || []).filter((r) => (!r.fileName || r.fileName.endsWith(".html")) && !r.route.endsWith(".html") && !r.route.startsWith("/api/")).map((r) => ({ loc: r.route })) || [];
      if (buildTimeMeta.hasPrerenderedRoutesPayload) {
        await mkdir(resolve(nitro.options.output.publicDir, "__sitemap__"), { recursive: true });
        await writeFile(resolve(nitro.options.output.publicDir, "__sitemap__/routes.json"), JSON.stringify(prerenderUrls));
        nitro.logger.log(chalk.gray(
          "  \u251C\u2500 /__sitemap__/routes.json (0ms)"
        ));
        return;
      }
      if (!buildTimeMeta.prerenderSitemap)
        return;
      sitemapGenerated = true;
      let start = Date.now();
      const _routeRulesMatcher = toRouteMatcher(
        createRouter({ routes: nitro.options.routeRules })
      );
      const routeMatcher = (path) => {
        const matchedRoutes = _routeRulesMatcher.matchAll(withoutBase(withoutTrailingSlash(path), nuxt.options.app.baseURL)).reverse();
        if (sitemapImages[path]) {
          matchedRoutes.push({
            sitemap: {
              images: sitemapImages[path]
            }
          });
        }
        return defu({}, ...matchedRoutes);
      };
      const callHook = async (ctx) => {
        await nuxt.hooks.callHook("sitemap:prerender", ctx);
        await nuxt.hooks.callHook("sitemap:resolved", ctx);
      };
      const options = {
        moduleConfig,
        canonicalUrlResolver: createSitePathResolver({ canonical: true, absolute: true, withBase: true }),
        relativeBaseUrlResolver: createSitePathResolver({ absolute: false, withBase: true }),
        buildTimeMeta,
        extraRoutes: generateExtraRoutesFromNuxtConfig(),
        getRouteRulesForPath: routeMatcher,
        callHook,
        prerenderUrls,
        pages: await pagesPromise
      };
      const logs = [];
      if (moduleConfig.sitemaps) {
        start = Date.now();
        const { xml, sitemaps } = await buildSitemapIndex(options);
        const indexHookCtx = { sitemap: xml, sitemapName: "index" };
        await nuxt.hooks.callHook("sitemap:output", indexHookCtx);
        await writeFile(resolve(nitro.options.output.publicDir, "sitemap_index.xml"), indexHookCtx.sitemap);
        const generateTimeMS = Date.now() - start;
        logs.push(`/sitemap_index.xml (${generateTimeMS}ms)`);
        for (const sitemap of sitemaps) {
          let sitemapXml = await buildSitemap({
            ...options,
            sitemap
          });
          const ctx = { sitemap: sitemapXml, sitemapName: sitemap.sitemapName };
          await nuxt.hooks.callHook("sitemap:output", ctx);
          sitemapXml = ctx.sitemap;
          await writeFile(resolve(nitro.options.output.publicDir, `${sitemap.sitemapName}-sitemap.xml`), sitemapXml);
          const generateTimeMS2 = Date.now() - start;
          logs.push(`/${sitemap.sitemapName}-sitemap.xml (${generateTimeMS2}ms)`);
        }
      } else {
        let sitemapXml = await buildSitemap(options);
        const ctx = { sitemap: sitemapXml, sitemapName: moduleConfig.sitemapName };
        await nuxt.hooks.callHook("sitemap:output", ctx);
        sitemapXml = ctx.sitemap;
        await writeFile(resolve(nitro.options.output.publicDir, moduleConfig.sitemapName), sitemapXml);
        const generateTimeMS = Date.now() - start;
        logs.push(`/${moduleConfig.sitemapName} (${generateTimeMS}ms)`);
      }
      if (moduleConfig.debug) {
        const sources = await resolveAsyncDataSources(options);
        start = Date.now();
        await mkdir(resolve(nitro.options.output.publicDir, "__sitemap__"), { recursive: true });
        await writeFile(resolve(nitro.options.output.publicDir, "__sitemap__", "debug.json"), JSON.stringify({
          moduleConfig,
          buildTimeMeta,
          data: sources,
          _sources: sources.map((s) => {
            return {
              ...s,
              urls: s.urls.length || 0
            };
          })
        }));
        const generateTimeMS = Date.now() - start;
        logs.push(`/__sitemap__/debug.json (${generateTimeMS}ms)`);
      }
      for (const k in logs)
        nitro.logger.log(chalk.gray(`  ${Number.parseInt(k) === logs.length - 1 ? "\u2514\u2500" : "\u251C\u2500"} ${logs[k]}`));
    };
    nitro.hooks.hook("rollup:before", async () => {
      await outputSitemap();
    });
    nitro.hooks.hook("close", async () => {
      await outputSitemap();
    });
  });
}

const module = defineNuxtModule({
  meta: {
    name: "nuxt-simple-sitemap",
    compatibility: {
      nuxt: "^3.7.0",
      bridge: false
    },
    configKey: "sitemap"
  },
  defaults: {
    enabled: true,
    credits: true,
    cacheTtl: 1e3 * 60 * 60,
    // cache for 60 minutes
    debug: false,
    defaultSitemapsChunkSize: 1e3,
    autoLastmod: true,
    inferStaticPagesAsRoutes: true,
    discoverImages: true,
    dynamicUrlsApiEndpoint: "/api/_sitemap-urls",
    urls: [],
    sortEntries: true,
    xsl: "/__sitemap__/style.xsl",
    xslTips: true,
    strictNuxtContentPaths: false,
    runtimeCacheStorage: true,
    sitemapName: "sitemap.xml",
    // cacheControlHeader: 'max-age=600, must-revalidate',
    defaults: {},
    // index sitemap options filtering
    include: [],
    exclude: []
  },
  async setup(config, nuxt) {
    const logger = useLogger("nuxt-simple-sitemap");
    logger.level = config.debug || nuxt.options.debug ? 4 : 3;
    if (config.enabled === false) {
      logger.debug("The module is disabled, skipping setup.");
      return;
    }
    config.xslColumns = config.xslColumns || [
      { label: "URL", width: "50%" },
      { label: "Images", width: "25%", select: "count(image:image)" },
      {
        label: "Last Updated",
        width: "25%",
        select: "concat(substring(sitemap:lastmod,0,11),concat(' ', substring(sitemap:lastmod,12,5)),concat(' ', substring(sitemap:lastmod,20,6)))"
      }
    ];
    const { resolve } = createResolver(import.meta.url);
    await installNuxtSiteConfig();
    updateSiteConfig({
      _context: "nuxt-simple-sitemap:config",
      trailingSlash: config.trailingSlash,
      url: config.siteUrl
    });
    nuxt.options.nitro.storage = nuxt.options.nitro.storage || {};
    if (nuxt.options._generate) {
      nuxt.options.nitro.storage["nuxt-simple-sitemap"] = {
        driver: "memory"
      };
    } else if (config.runtimeCacheStorage && !nuxt.options.dev && typeof config.runtimeCacheStorage === "object") {
      nuxt.options.nitro.storage["nuxt-simple-sitemap"] = config.runtimeCacheStorage;
    }
    if (!config.sitemapName.endsWith("xml")) {
      const newName = `${config.sitemapName.split(".")[0]}.xml`;
      logger.warn(`You have provided a \`sitemapName\` that does not end with \`.xml\`. This is not supported by search engines, renaming to \`${newName}\`.`);
      config.sitemapName = newName;
    }
    config.sitemapName = withoutLeadingSlash(config.sitemapName);
    if (hasNuxtModule("nuxt-simple-robots")) {
      const robotsVersion = await getNuxtModuleVersion("nuxt-simple-robots");
      if (!await hasNuxtModuleCompatibility("nuxt-simple-robots", ">=3"))
        logger.warn(`You are using nuxt-simple-robots v${robotsVersion}. For the best compatibility, please upgrade to nuxt-simple-robots v3.0.0 or higher.`);
      nuxt.hooks.hook("robots:config", (robotsConfig) => {
        robotsConfig.sitemap.push(config.sitemaps ? "/sitemap_index.xml" : `/${config.sitemapName}`);
      });
    }
    if (typeof config.urls === "function")
      config.urls = [...await config.urls()];
    else if (Array.isArray(config.urls))
      config.urls = [...await config.urls];
    let isI18nMap = false;
    let nuxtI18nConfig = {};
    let resolvedAutoI18n = typeof config.autoI18n === "boolean" ? false : config.autoI18n || false;
    const hasDisabledAutoI18n = typeof config.autoI18n === "boolean" && !config.autoI18n;
    let normalisedLocales = [];
    if (hasNuxtModule("@nuxtjs/i18n")) {
      const i18nVersion = await getNuxtModuleVersion("@nuxtjs/i18n");
      if (!await hasNuxtModuleCompatibility("@nuxtjs/i18n", ">=8"))
        logger.warn(`You are using @nuxtjs/i18n v${i18nVersion}. For the best compatibility, please upgrade to @nuxtjs/i18n v8.0.0 or higher.`);
      nuxtI18nConfig = await getNuxtModuleOptions("@nuxtjs/i18n") || {};
      normalisedLocales = mergeOnKey((nuxtI18nConfig.locales || []).map((locale) => typeof locale === "string" ? { code: locale } : locale), "code");
      const usingI18nPages = Object.keys(nuxtI18nConfig.pages || {}).length;
      if (usingI18nPages && !hasDisabledAutoI18n) {
        for (const pageLocales of Object.values(nuxtI18nConfig?.pages)) {
          for (const locale in pageLocales) {
            if (!pageLocales[locale] || pageLocales[locale].includes("["))
              continue;
            const hreflang = normalisedLocales.find((l) => l.code === locale)?.iso || locale;
            const alternatives = Object.keys(pageLocales).map((l) => ({
              hreflang,
              href: pageLocales[l]
            }));
            if (nuxtI18nConfig.defaultLocale && pageLocales[nuxtI18nConfig.defaultLocale])
              alternatives.push({ hreflang: "x-default", href: pageLocales[nuxtI18nConfig.defaultLocale] });
            if (Array.isArray(config.urls)) {
              config.urls.push({
                loc: pageLocales[locale],
                alternatives
              });
            }
          }
        }
      }
      const hasDisabledAlternativePrefixes = typeof config.autoAlternativeLangPrefixes === "boolean" && !config.autoAlternativeLangPrefixes;
      const hasSetAlternativePrefixes = Array.isArray(config.autoAlternativeLangPrefixes) && config.autoAlternativeLangPrefixes.length || Object.keys(config.autoAlternativeLangPrefixes || {}).length;
      const hasSetAutoI18n = typeof config.autoI18n === "object" && Object.keys(config.autoI18n).length;
      const hasI18nConfigForAlternatives = nuxtI18nConfig.strategy !== "no_prefix" && nuxtI18nConfig.locales;
      if (!hasSetAutoI18n && !hasDisabledAutoI18n && !hasDisabledAlternativePrefixes && hasI18nConfigForAlternatives) {
        if (!hasSetAlternativePrefixes) {
          resolvedAutoI18n = {
            defaultLocale: nuxtI18nConfig.defaultLocale,
            locales: normalisedLocales,
            strategy: nuxtI18nConfig.strategy
          };
        } else if (Array.isArray(config.autoAlternativeLangPrefixes)) {
          resolvedAutoI18n = {
            defaultLocale: nuxtI18nConfig.defaultLocale,
            locales: config.autoAlternativeLangPrefixes.map((l) => ({ code: l })),
            strategy: nuxtI18nConfig.strategy || "prefix"
          };
        }
      }
      if (typeof config.sitemaps === "undefined" && !!resolvedAutoI18n && nuxtI18nConfig.strategy !== "no_prefix") {
        isI18nMap = true;
        config.sitemaps = {};
        for (const locale of resolvedAutoI18n.locales) {
          config.sitemaps[locale.iso || locale.code] = {};
        }
      }
    }
    let pages = [];
    nuxt.hooks.hook("modules:done", () => {
      extendPages((_pages) => {
        pages = _pages;
      });
    });
    const pagesPromise = new Promise((resolve2) => {
      nuxt.hooks.hook("nitro:config", (nitroConfig) => {
        nitroConfig.virtual["#nuxt-simple-sitemap/pages.mjs"] = async () => {
          const payload = config.inferStaticPagesAsRoutes ? convertNuxtPagesToSitemapEntries(pages, {
            autoLastmod: config.autoLastmod,
            defaultLocale: nuxtI18nConfig.defaultLocale || "en",
            strategy: nuxtI18nConfig.strategy || "no_prefix",
            routeNameSeperator: nuxtI18nConfig.routesNameSeparator,
            normalisedLocales
          }) : [];
          resolve2(payload);
          return `export default ${JSON.stringify(payload, null, 2)}`;
        };
      });
    });
    extendTypes("nuxt-simple-sitemap", async ({ typesPath }) => {
      return `
declare module 'nitropack' {
  interface NitroRouteRules {
    index?: boolean
    sitemap?: import('${typesPath}').SitemapItemDefaults
  }
  interface NitroRouteConfig {
    index?: boolean
    sitemap?: import('${typesPath}').SitemapItemDefaults
  }
  interface NitroRuntimeHooks {
    'sitemap:resolved': (ctx: import('${typesPath}').SitemapRenderCtx) => void | Promise<void>
    'sitemap:output': (ctx: import('${typesPath}').SitemapOutputHookCtx) => void | Promise<void>
  }
}
`;
    });
    const prerenderedRoutes = nuxt.options.nitro.prerender?.routes || [];
    const prerenderSitemap = nuxt.options._generate || prerenderedRoutes.includes(`/${config.sitemapName}`) || prerenderedRoutes.includes("/sitemap_index.xml");
    if (prerenderSitemap) {
      const routeRules = {
        headers: {
          "Content-Type": "text/xml; charset=UTF-8",
          "Cache-Control": "max-age=600, must-revalidate"
        }
      };
      nuxt.options.routeRules = nuxt.options.routeRules || {};
      if (config.sitemaps) {
        nuxt.options.routeRules["/sitemap_index.xml"] = routeRules;
        if (typeof config.sitemaps === "object") {
          for (const k in config.sitemaps)
            nuxt.options.routeRules[`/${k}-sitemap.xml`] = routeRules;
        } else {
          nuxt.options.routeRules[`/${config.sitemapName}`] = routeRules;
        }
      } else {
        nuxt.options.routeRules[`/${config.sitemapName}`] = routeRules;
      }
    }
    const isPrerenderingRoutes = prerenderedRoutes.length > 0 || !!nuxt.options.nitro.prerender?.crawlLinks;
    const buildTimeMeta = {
      // @ts-expect-error runtime types
      isNuxtContentDocumentDriven: hasNuxtModule("@nuxt/content") && (!!nuxt.options.content?.documentDriven || config.strictNuxtContentPaths),
      hasApiRoutesUrl: !!await findPath(resolve(nuxt.options.serverDir, "api/_sitemap-urls")) || config.dynamicUrlsApiEndpoint !== "/api/_sitemap-urls",
      hasPrerenderedRoutesPayload: !nuxt.options.dev && !prerenderSitemap && isPrerenderingRoutes,
      prerenderSitemap,
      version
    };
    const moduleConfig = {
      isI18nMap,
      autoLastmod: config.autoLastmod,
      xsl: config.xsl,
      xslTips: config.xslTips,
      cacheTtl: config.cacheTtl,
      defaultSitemapsChunkSize: config.defaultSitemapsChunkSize,
      // @ts-expect-error runtime types
      runtimeCacheStorage: typeof config.runtimeCacheStorage === "boolean" ? "default" : config.runtimeCacheStorage.driver,
      autoAlternativeLangPrefixes: config.autoAlternativeLangPrefixes,
      credits: config.credits,
      defaults: config.defaults,
      xslColumns: config.xslColumns,
      include: config.include,
      exclude: config.exclude,
      sitemaps: config.sitemaps,
      sitemapName: config.sitemapName,
      sortEntries: config.sortEntries,
      dynamicUrlsApiEndpoint: config.dynamicUrlsApiEndpoint,
      urls: config.urls,
      debug: config.debug,
      // needed for nuxt/content integration
      discoverImages: config.discoverImages
    };
    if (resolvedAutoI18n)
      moduleConfig.autoI18n = resolvedAutoI18n;
    nuxt.options.runtimeConfig["nuxt-simple-sitemap"] = {
      version,
      // @ts-expect-error untyped
      moduleConfig,
      buildTimeMeta
    };
    if (config.debug || nuxt.options.dev) {
      addServerHandler({
        route: "/api/__sitemap__/debug",
        handler: resolve("./runtime/routes/debug")
      });
      addCustomTab({
        // unique identifier
        name: "nuxt-simple-sitemap",
        // title to display in the tab
        title: "Sitemap",
        // any icon from Iconify, or a URL to an image
        icon: "carbon:tree-view",
        // iframe view
        view: {
          type: "iframe",
          src: "/api/__sitemap__/debug"
        }
      });
    }
    nuxt.hooks.hook("nitro:config", (nitroConfig) => {
      nitroConfig.virtual["#nuxt-simple-sitemap/extra-routes.mjs"] = () => {
        const { prerenderUrls, routeRules } = generateExtraRoutesFromNuxtConfig();
        return [
          // no wild cards supported
          `const routeRules = ${JSON.stringify(routeRules)}`,
          `const prerenderUrls = ${JSON.stringify(prerenderUrls)}`,
          "export default { routeRules, prerenderUrls }"
        ].join("\n");
      };
    });
    if (config.xsl === "/__sitemap__/style.xsl") {
      addServerHandler({
        route: config.xsl,
        handler: resolve("./runtime/routes/sitemap.xsl")
      });
      config.xsl = withBase(config.xsl, nuxt.options.app.baseURL);
      if (prerenderSitemap)
        addPrerenderRoutes(config.xsl);
    }
    if (config.sitemaps) {
      addServerHandler({
        route: "/sitemap_index.xml",
        handler: resolve("./runtime/routes/sitemap_index.xml")
      });
      addServerHandler({
        handler: resolve("./runtime/middleware/[sitemap]-sitemap.xml")
      });
    }
    addServerHandler({
      route: `/${config.sitemapName}`,
      handler: resolve("./runtime/routes/sitemap.xml")
    });
    if (buildTimeMeta.isNuxtContentDocumentDriven) {
      addServerPlugin(resolve("./runtime/plugins/nuxt-content"));
      addServerHandler({
        route: "/api/__sitemap__/document-driven-urls",
        handler: resolve("./runtime/routes/document-driven-urls")
      });
    }
    setupPrerenderHandler(moduleConfig, buildTimeMeta, pagesPromise);
  }
});

export { module as default };
