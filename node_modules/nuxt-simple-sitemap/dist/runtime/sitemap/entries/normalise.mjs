import { hasProtocol, joinURL } from "ufo";
import { defu } from "defu";
import { fixSlashes } from "site-config-stack";
import { createFilter } from "../../util/urlFilter.mjs";
import { mergeOnKey } from "../../util/pageUtils.mjs";
export async function normaliseSitemapData(data, options) {
  const {
    defaults,
    exclude,
    include,
    autoLastmod,
    autoI18n,
    isI18nMap
  } = options.moduleConfig;
  const combinedInclude = [...options.sitemap?.include || [], ...include || []];
  const combinedExclude = [...options.sitemap?.exclude || [], ...exclude || []];
  const urlFilter = createFilter({ include: combinedInclude, exclude: combinedExclude });
  function resolve(s) {
    if (!s)
      return;
    s = typeof s === "string" ? s : s.toString();
    if (hasProtocol(s, { acceptRelative: true, strict: false })) {
      if (s.startsWith(options.canonicalUrlResolver("/")))
        s = s.replace(options.canonicalUrlResolver("/"), "");
      else
        return s;
    }
    return options.canonicalUrlResolver(s);
  }
  const defaultEntryData = defu(options.sitemap?.defaults, defaults);
  if (autoLastmod)
    defaultEntryData.lastmod = defaultEntryData.lastmod || /* @__PURE__ */ new Date();
  let entries = data.map((e) => typeof e === "string" ? { loc: e } : e).map((e) => {
    e = { ...e };
    if (e.url) {
      e.loc = e.url;
      delete e.url;
    }
    e.loc = fixSlashes(false, e.loc);
    e = defu(e, defaultEntryData);
    return e;
  }).map((e) => {
    const routeRules = options.getRouteRulesForPath(e.loc);
    if (routeRules.index === false)
      return false;
    return defu(routeRules.sitemap || {}, e);
  }).filter(Boolean);
  if (autoI18n?.locales) {
    const entriesByLoc = entries.reduce((acc, e) => {
      const match = e.loc.match(new RegExp(`^/(${autoI18n.locales.map((l) => l.code).join("|")})(.*)`));
      let loc = e.loc;
      let prefix = null;
      if (match) {
        loc = match[2] || "/";
        prefix = match[1];
      }
      acc[loc] = acc[loc] || [];
      acc[loc].push({ entry: e, prefix });
      return acc;
    }, {});
    Object.entries(entriesByLoc).forEach(([loc, childEntry]) => {
      autoI18n.locales.map((l) => l.code).forEach((prefix) => {
        if (!childEntry.map((e) => e.prefix).filter(Boolean).includes(prefix)) {
          if (autoI18n.strategy === "prefix")
            entries.push({ ...childEntry[0].entry, loc: joinURL(`/${prefix}`, loc) });
          else if (autoI18n.strategy === "prefix_except_default")
            entries.push({ ...childEntry[0].entry, loc: prefix === autoI18n.defaultLocale ? loc : joinURL(`/${prefix}`, loc) });
        }
      });
    });
    entries.map((e) => {
      let withoutPrefix = e.loc.replace(new RegExp(`^/(${autoI18n.locales.map((l) => l.code).join("|")})(.*)`), "$2");
      withoutPrefix = withoutPrefix || "/";
      let xDefault = e.loc;
      if (autoI18n.strategy === "prefix") {
        xDefault = joinURL("/", autoI18n.defaultLocale, withoutPrefix);
      } else if (autoI18n.strategy === "prefix_except_default") {
        xDefault = withoutPrefix;
      }
      e.alternatives = e.alternatives || [
        ...autoI18n.locales.map((locale) => {
          const isDefault = locale.code === autoI18n.defaultLocale;
          let href = "";
          if (autoI18n.strategy === "prefix") {
            href = joinURL("/", locale.code, withoutPrefix);
          } else if (autoI18n.strategy === "prefix_except_default") {
            if (isDefault) {
              href = withoutPrefix;
            } else {
              href = joinURL("/", locale.code, withoutPrefix);
            }
          }
          const hreflang = locale.iso || locale.code;
          return {
            hreflang,
            href
          };
        }),
        { hreflang: "x-default", href: xDefault }
      ];
      return e;
    });
    if (autoI18n.strategy === "prefix") {
      entries = entries.filter((e) => e.loc.match(new RegExp(`^/(${autoI18n.locales.map((l) => l.code).join("|")})(.*)`)));
    }
  }
  let filteredEntries = entries.filter((e) => e && urlFilter(e.loc));
  if (isI18nMap && options.sitemap?.sitemapName) {
    const locale = options.sitemap?.sitemapName;
    filteredEntries = filteredEntries.filter((e) => {
      const alternativeEntry = e.alternatives?.find((a) => a.hreflang === locale);
      if (!alternativeEntry)
        return false;
      return alternativeEntry.href === e.loc;
    });
  }
  function normaliseEntry(e) {
    if (e.lastmod) {
      const date = normaliseDate(e.lastmod);
      if (date)
        e.lastmod = date;
      else
        delete e.lastmod;
    }
    if (!e.lastmod)
      delete e.lastmod;
    e.loc = resolve(e.loc);
    if (e.alternatives) {
      e.alternatives = mergeOnKey(e.alternatives.map((e2) => {
        const a = { ...e2 };
        if (typeof a.href === "string")
          a.href = resolve(a.href);
        else if (typeof a.href === "object" && a.href)
          a.href = resolve(a.href.href);
        return a;
      }), "hreflang");
    }
    if (e.images) {
      e.images = mergeOnKey(e.images.map((i) => {
        i = { ...i };
        i.loc = resolve(i.loc);
        return i;
      }), "loc");
    }
    if (e.videos) {
      e.videos = e.videos.map((v) => {
        v = { ...v };
        v.contentLoc = resolve(v.contentLoc);
        return v;
      });
    }
    return e;
  }
  function sortEntries(entries2) {
    if (options.moduleConfig.sortEntries) {
      return entries2.sort((a, b) => {
        return a.loc.localeCompare(b.loc, void 0, { numeric: true });
      }).sort((a, b) => {
        const aSegments = a.loc.split("/").length;
        const bSegments = b.loc.split("/").length;
        if (aSegments > bSegments)
          return 1;
        if (aSegments < bSegments)
          return -1;
        return 0;
      });
    }
    return entries2;
  }
  function normaliseEntries(entries2) {
    return sortEntries(mergeOnKey(entries2.map(normaliseEntry), "loc"));
  }
  const ctx = { urls: normaliseEntries(filteredEntries), sitemapName: options.sitemap?.sitemapName || "sitemap" };
  if (options.callHook)
    await options.callHook(ctx);
  return normaliseEntries(ctx.urls);
}
export function normaliseDate(date) {
  const d = typeof date === "string" ? new Date(date) : date;
  if (!(d instanceof Date))
    return false;
  const z = (n) => `0${n}`.slice(-2);
  return `${d.getUTCFullYear()}-${z(d.getUTCMonth() + 1)}-${z(d.getUTCDate())}T${z(d.getUTCHours())}:${z(d.getUTCMinutes())}:${z(d.getUTCSeconds())}+00:00`;
}
